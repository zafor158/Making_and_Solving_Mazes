{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ObDMVakj4ydf"
      },
      "source": [
        "<div align=\"right\" style=\"text-align: right\"><i>Adopted from Peter Norvig<br></i></div>\n",
        "\n",
        "# Making and Solving Mazes\n",
        "\n",
        "Let's make some mazes! I'm thinking of mazes like this one, which is  a rectangular grid of squares, with walls on some of the sides of squares, and openings on other sides. The goal is to get from the red arrow to the green arrow.\n",
        "\n",
        "![Wikipedia](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Maze_simple.svg/475px-Maze_simple.svg.png)\n",
        "\n",
        "The two main constraints are that there should be a path from entrance to exit, and it should be ***fun*** to solve the maze with pencil, paper, and brain power&mdash;not too easy, but also not impossible.  \n",
        "\n",
        "As I think about how to model a maze on the computer, it seems like a **graph** is the right model: the nodes of\n",
        "the graph are the squares of the grid, and the edges of the graph are the openings between adjacent squares. So what properties of a graph make a good maze?\n",
        "- There must be a path from entrance to exit.\n",
        "- There must not be too many such paths; maybe it is best if there is only one.\n",
        "- Probably the graph should be *singly connected*&mdash;there shouldn't be islands of squares that are unreachable from the start. In fact, maybe we want exactly one path between any two squares.\n",
        "- The path should have many twists; it would be too easy if it was mostly straight.\n",
        "\n",
        "I know that a **tree** has all these properties except the last one. So my goal has become: *Superimpose a tree over the grid, covering every square, and make sure the paths are twisty.* Here's how I'll do it:\n",
        "\n",
        "- Start with a grid with no edges (every square is surrounded by walls on all sides).\n",
        "- Add edges (that is, knock down walls) for the entrance at upper left and exit at lower right.\n",
        "- Place the root of the tree in some square.\n",
        "- Then repeat until the tree covers the whole grid:\n",
        "  * Select some node already in the tree.\n",
        "  * Randomly select a neighbor that hasn't been added to the tree yet.\n",
        "  * Add an edge (knock down the wall) from the node to the neighbor.\n",
        "  \n",
        "In the example below, the root, `A`, has been placed in the upper-left corner, and  two branches,\n",
        "`A-B-C-D` and `A-b-c-d`, have been randomly chosen (well, not actually random; they are starting to create the same maze as in the diagram above):\n",
        "\n",
        "     o  o--o--o--o--o--o--o--o--o--o\n",
        "     | A  b  c|  |  |  |  |  |  |  |\n",
        "     o  o--o  o--o--o--o--o--o--o--o\n",
        "     | B|  | d|  |  |  |  |  |  |  |\n",
        "     o  o--o--o--o--o--o--o--o--o--o\n",
        "     | C  D|  |  |  |  |  |  |  |  |\n",
        "     o--o--o--o--o--o--o--o--o--o--o\n",
        "     |  |  |  |  |  |  |  |  |  |  |\n",
        "     o--o--o--o--o--o--o--o--o--o--o\n",
        "     |  |  |  |  |  |  |  |  |  |  |\n",
        "     o--o--o--o--o--o--o--o--o--o  o\n",
        "    \n",
        "Next I select node `d` and extend it to `e` (at which point there are no available neighbors, so `e` will not be selected in the future), and then I select `D` and extend from there all the way to `N`, at each step selecting the node I just added:\n",
        "\n",
        "     o  o--o--o--o--o--o--o--o--o--o\n",
        "     | A  b  c|  |  |  |  |  |  |  |\n",
        "     o  o--o  o--o--o--o--o--o--o--o\n",
        "     | B| e  d|  | N|  |  |  |  |  |\n",
        "     o  o--o--o--o  o--o--o--o--o--o\n",
        "     | C  D|  |  | M|  |  |  |  |  |\n",
        "     o--o  o--o--o  o--o--o--o--o--o\n",
        "     | F  E|  | K  L|  |  |  |  |  |\n",
        "     o  o--o--o  o--o--o--o--o--o--o\n",
        "     | G  H  I  J|  |  |  |  |  |  |\n",
        "     o--o--o--o--o--o--o--o--o--o  o\n",
        "     \n",
        "Continue like this until every square in the grid has been added to the tree. At that point there will be a path from start to goal. Some walls will remain; some will be knocked down.\n",
        "\n",
        "\n",
        "# Making Random Trees\n",
        "\n",
        "I'll make the following implementation choices:\n",
        "\n",
        "- A tree will be represented as a set of edges.\n",
        "- An `Edge` is a tuple of two nodes. Edges are bidirectional, so to avoid confusion we will always us the tuple that is in sorted order: always `(A, B)`, never `(B, A)`. The constructor `edge` enforces that.\n",
        "- A node in a tree can be anything: a number, a letter, ...  In this notebook we will make trees where the nodes are squares in a grid, but the function `random_tree` accepts nodes of any type.\n",
        "- The algorithm for `random_tree(nodes, neighbors, pop)` works as follows:\n",
        "  * The arguments are:\n",
        "    - `nodes`: a collection of nodes.\n",
        "    - `neighbors`: a function such that `neighbors(node)` returns a set of nodes.\n",
        "    - `pop`: a function such that `pop(frontier)` removes and returns an element from `frontier`.\n",
        "  * The function keeps track of three collections:\n",
        "    - `tree`: a set of edges that constitutes the tree.\n",
        "    - `nodes`: the set of nodes that have not yet been added to the tree, but will be.\n",
        "    - `frontier`: a queue of nodes in the tree that are eligible to have an edge added.\n",
        "  * On each iteration:\n",
        "    - Use `pop` to pick a `node` from the frontier, and find the neighbors that are not already in the tree.\n",
        "    - If there are any neighbors, randomly pick one (`nbr`), add `edge(node, nbr)` to `tree`, remove the\n",
        "      neighbor from `nodes`, and keep both the node and the neighbor on the frontier. If there are no neighbors,\n",
        "      drop the node from the frontier.\n",
        "  * When no `nodes` remain, return `tree`."
      ]
    },
